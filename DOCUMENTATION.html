<h1>Documentation for libinetsocket</h1>

<h2>Clients</h2>

<h3><code>create_isocket()</code></h3>

<pre><code>int create_isocket(const char* host, const char* service, char proto_osi4, char proto_osi3, int flags)
</code></pre>

<p><code>create_isocket()</code> creates and connects a new socket. The parameters have to be filled like this:</p>

<ul>
<li><code>host</code> is a string (0-terminated) containing the hostname or IP address of the target host</li>
<li><code>service</code> is a string (0-terminated) containing the portname or service (e.g. <code>http</code>)</li>
<li><code>proto_osi4</code> is a value representing the protocol on OSI layer 4 which we want to use (defined as macros): <code>TCP</code>, <code>UDP</code> or <code>BOTH</code> when libsocket should choose</li>
<li><code>proto_osi3</code> is a value representing the protocol on OSI layer 3 which we want to use (defined as macros): <code>IPv6</code>, <code>IPv4</code> or <code>BOTH</code> when libsocket should choose</li>
<li><code>flags</code> is <code>SOCK_CLOEXEC</code> and/or <code>SOCK_NONBLOCK</code> (as specified in <code>socket(2)</code>). <code>SOCK_CLOEXEC</code> will close the socket if you call <code>exec*()</code>. <code>SOCK_NONBLOCK</code> will return -1 instead of
waiting for data on the socket.</li>
</ul>

<p>The return value is either a valid file descriptor on which you can execute <code>write()</code> or <code>read()</code> (from <code>unistd.h</code>). If there's an error when creating
that socket, it returns -1.</p>

<p>Important for UDP sockets: The returned socket file descriptor may be used with <code>read()</code> and <code>write()</code> as well as TCP sockets. If you want to use <code>sendto()</code> and
<code>recvfrom()</code>, don't use this library. But generally, it is not necessary to use sendto and recvfrom: When you use connected datagram sockets,
each <code>read()</code> call will create a new datagram.</p>

<h3><code>reconnect_isocket()</code></h3>

<pre><code>int reconnect_isocket(int sfd, char* host, char* service);
</code></pre>

<p><code>reconnect_isocket()</code> is an easy way to connect an existing socket to a new peer. It is faster and more elegant than destroying the first socket with <code>destroy_isocket()</code>
and make a new with <code>create_isocket()</code>. <strong><em>IMPORTANT: IT MAY ONLY BE USED WITH UDP SOCKETS! IF USED WITH TCP SOCKETS, IT WON'T WORK!!!</em></strong> The parameters:</p>

<ul>
<li><code>sfd</code> is the existing Socket File Descriptor</li>
<li><code>host</code> and <code>service</code> like in <code>create_isocket()</code>
which you chose at <code>create_isocket()</code> because it is impossible to get the socktype from the file descriptor.</li>
</ul>

<p>This function returns either 0 (Success) or -1 (Failure).</p>

<h3><code>shutdown_isocket()</code></h3>

<pre><code>int shutdown_isocket(int sfd, int method)
</code></pre>

<p><code>shutdown_isocket()</code> shuts a socket down. This means that (READ) you cannot read data anymore respectively (WRITE) you cannot write data anymore
and the other peer gets an EOF signal (<code>read()</code> returns 0).</p>

<ul>
<li><code>sfd</code> is the Socket File Descriptor</li>
<li><code>method</code> is either READ, WRITE or READ|WRITE (ORed).</li>
</ul>

<p>This function returns either 0 (Success) or -1 (Failure)</p>

<h3><code>destroy_isocket()</code></h3>

<pre><code>int destroy_isocket(int sfd)
</code></pre>

<p><code>destroy_isocket()</code> <code>close()</code>s the specified Socket file descriptor <code>sfd</code>. It does not perform a <code>shutdown()</code> on it because that would produce
an error if you shut it down before. But that's equal because <code>close()</code> also sends EOF.</p>

<p>This function returns either 0 (Success) or -1 (Failure)</p>

<h2>Server</h2>

<p>libsocket also supports INET server sockets (also called Passive Sockets).</p>

<h3><code>create_issocket()</code></h3>

<p>'issocket' stands for 'Internet Server Socket', not for 'is socket'. :)</p>

<pre><code>int create_issocket(const char* bind_addr, const char* bind_port, char proto_osi4, char proto_osi3);
</code></pre>

<p>Creates a new server socket:</p>

<ul>
<li><code>bind_addr</code> is the address to bind to. It's normally good when you specify "0.0.0.0".</li>
<li><code>bind_port</code> is the port to bind to.</li>
<li>proto_osi4 is either TCP or UDP. If it's UDP, the socket doesn't <code>listen()</code>.</li>
<li>proto_osi3 is either IPv4 or IPv6</li>
</ul>

<p>The call to <code>listen()</code> (which is not executed when using UDP sockets uses the biggest linux backlog size 128. You should change it in the source code if you
want another value.</p>

<p>This function returns an int value suitable for calls with <code>accept()</code> and <code>accept_issocket()</code>.</p>

<p>A with this function created socket may be destroyed with <code>destroy_isocket()</code>.</p>

<h3><code>accept_issocket()</code></h3>

<pre><code>int accept_issocket(int sfd, char* src_host, size_t src_host_len, char* src_service, size_t src_service_len, int flags);
</code></pre>

<p><code>accept_issocket()</code> performs an action similar to <code>accept()</code>. <strong>It may not be called on UDP server sockets.</strong> </p>

<ul>
<li><code>sfd</code> is the socket file descriptor</li>
<li><code>src_host</code> is a pointer to a buffer into which the lib writes the hostname of the client. <code>src_host_len</code> is the length of its buffer. More bytes are truncated</li>
<li><code>src_service</code> and <code>src_service_len</code> is the same like <code>src_host</code> and <code>src_host_len</code>, but for the ports</li>
<li><code>flags</code> may be <code>NUMERIC</code>, which results in numeric host and service names.</li>
</ul>

<p><code>accept_issocket()</code> returns a file descriptor for a connection to the client which is to be used with <code>read()</code> and <code>write()</code>. 
In case of failure, it returns -1. <code>accept_issocket()</code> blocks until a client connects.</p>

<h3><code>recvfrom_issocket()</code></h3>

<pre><code>size_t recvfrom_issocket(int sfd, void* buffer, size_t size, char* src_host, size_t src_host_len, char* src_service, size_t src_service_len, int flags)
</code></pre>

<p><code>recvfrom_issocket()</code> receives some bytes from a UDP socket. It also may work with STREAM sockets (as TCP) but it is recommended to use <code>accept_issocket()</code> with TCP sockets.</p>

<p>The parameters are:</p>

<ul>
<li><code>sfd</code> is the socket file descriptor</li>
<li><code>buffer</code> is a memory block for the received bytes</li>
<li><code>size</code> is the size of the buffer</li>
<li><code>src_host</code> is a buffer for the client name and <code>src_host_len</code> its length</li>
<li><code>src_service</code> is a buffer for the client's port and <code>src_service_len</code> its length. If you use <code>NUMERIC</code> as flag (see next parameter), 
you have to give a buffer of a length of 6 or more - elsewise, the internally used <code>getnameinfo()</code> will fail (5 digits for outgoing port plus a \0 byte) 
with "unknown error"! If you use the nonnumerical form, you have to give even more buffer space.</li>
<li><code>flags</code> may be NUMERIC which results in numeric client and port names.</li>
</ul>

<p><strong>Important: Please give buffers which are big enough to hold longer names - if you don't do so, <code>getnameinfo()</code> (which is used internally) will return with an unknown error.</strong></p>

<h1>Documentation for libunixsocket</h1>

<h2>Client</h2>

<h3><code>create_usocket()</code></h3>

<pre><code>int create_usocket(const char* path, int socktype);
</code></pre>

<p>Creates and connects a new UNIX domain socket file descriptor for a socket located at <code>path</code>, type <code>socktype</code>.
<code>socktype</code> is either <code>STREAM</code> or <code>DGRAM</code>. </p>

<p>Important for DGRAM sockets: Please think twice if you want to use DGRAM sockets in UNIX domain. They do not have any advantages
over STREAM sockets!</p>

<h3><code>reconnect_usocket()</code></h3>

<pre><code>int reconnect_usocket(int sfd, const char* path);
</code></pre>

<p>Reconnect a DGRAM UNIX socket <code>sfd</code> to the new UNIX socket <code>path</code>.</p>

<h3><code>shutdown_usocket()</code></h3>

<pre><code>int shutdown_usocket(int sfd, int method)
</code></pre>

<p><code>shutdown_socket()</code> shuts a socket down. This means that (READ) you cannot read data anymore respectively (WRITE) you cannot write data anymore
and the other peer gets an EOF signal (<code>read()</code> returns 0).</p>

<ul>
<li><code>sfd</code> is the Socket File Descriptor</li>
<li><code>method</code> is either READ, WRITE or READ|WRITE (ORed).</li>
</ul>

<h3><code>destroy_socket()</code></h3>

<pre><code>int destroy_usocket(int sfd)
</code></pre>

<p><code>destroy_socket()</code> shuts the socket down for READ and WRITE operations and <code>close()</code>s it.</p>

<h2>Server</h2>

<h3>`create_ussocket()</h3>

<pre><code>int create_ussocket(char* path, int socktype);
</code></pre>

<p>Create a new server socket and bind it to <code>path</code>. Protocol type (<code>socktype</code>) is either <code>DGRAM</code> for datagrams (<strong>NOT RECOMMENDED</strong>) or <code>STREAM</code>.</p>

<h3><code>accept_ussocket()</code></h3>

<pre><code>int accept_ussocket(int sfd, int flags);
</code></pre>

<p>Accept a new STREAM connection on socket <code>sfd</code>. <code>flags</code> may be <code>SOCK_NONBLOCK</code> which means that the new (returned) client socket won't block or <code>SOCK_CLOEXEC</code> which
means that the client socket will be closed if you call a syscall from the <code>exec()</code> family.</p>

<h3><code>recv_ussocket()</code></h3>

<pre><code>size_t recv_ussocket(int sfd, void* buf, size_t size)
</code></pre>

<p><code>recv_ussocket()</code> gets <code>size</code> bytes from <code>sfd</code> (usually a DGRAM socket) and writes them to <code>buf</code>.
Actually, it's the same like <code>read()</code>, but it's more clear if you use <code>recv_ussocket()</code>.</p>

<h1>Compile options</h1>

<p>If you specify the flag <code>-DVERBOSE</code> at compile time, libsocket uses STDERR to print information about occurred errors.
VERBOSE is not activated by default so libsocket is 'quiet'.</p>
