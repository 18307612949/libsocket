<h1>Documentation for libinetsocket</h1>

<h2>Clients</h2>

<h3><code>create_isocket()</code></h3>

<pre><code>int create_isocket(const char* host, const char* service, char proto_osi4, char proto_osi3)
</code></pre>

<p><code>create_isocket()</code> creates and connects a new socket. The parameters have to be filled like this:</p>

<ul>
<li><code>host</code> is a string (0-terminated) containing the hostname or IP address of the target host</li>
<li><code>service</code> is a string (0-terminated) containing the portname or service (e.g. <code>http</code>)</li>
<li><code>proto_osi4</code> is a value representing the protocol on OSI layer 4 which we want to use (defined as macros): <code>TCP</code>, <code>UDP</code> or <code>BOTH</code> when libsocket should choose</li>
<li><code>proto_osi3</code> is a value representing the protocol on OSI layer 3 which we want to use (defined as macros): <code>IPv6</code>, <code>IPv4</code> or <code>BOTH</code> when libsocket should choose</li>
</ul>

<p>The return value is either a valid file descriptor on which you can execute <code>write()</code> or <code>read()</code> (from <code>unistd.h</code>). If there's an error when creating
that socket, it returns -1.</p>

<p>Important for UDP sockets: The returned socket file descriptor may be used with <code>read()</code> and <code>write()</code> as well as TCP sockets. If you want to use <code>sendto()</code> and
<code>recvfrom()</code>, don't use this library. But generally, it is not necessary to use sendto and recvfrom: When you use connected datagram sockets,
each <code>read()</code> call will create a new datagram.</p>

<h3><code>reconnect_isocket()</code></h3>

<pre><code>int reconnect_isocket(int sfd, char* host, char* service, int socktype);
</code></pre>

<p><code>reconnect_isocket()</code> is an easy way to connect an existing socket to a new peer. It is faster and more elegant than destroying the first socket with <code>destroy_isocket()</code>
and make a new with <code>create_isocket()</code>. The parameters:</p>

<ul>
<li><code>sfd</code> is the existing Socket File Descriptor</li>
<li><code>host</code> and <code>service</code> like in <code>create_isocket()</code></li>
<li><code>socktype</code> is either TCP or UDP (the macro constants from <code>create_isocket()</code>). It has to be the type 
which you chose at <code>create_isocket()</code> because it is impossible to get the socktype from the file descriptor.</li>
</ul>

<p>This function returns either 0 (Success) or -1 (Failure).</p>

<h3><code>shutdown_isocket()</code></h3>

<pre><code>int shutdown_isocket(int sfd, int method)
</code></pre>

<p><code>shutdown_isocket()</code> shuts a socket down. This means that (READ) you cannot read data anymore respectively (WRITE) you cannot write data anymore
and the other peer gets an EOF signal (<code>read()</code> returns 0).</p>

<ul>
<li><code>sfd</code> is the Socket File Descriptor</li>
<li><code>method</code> is either READ, WRITE or READ|WRITE (ORed).</li>
</ul>

<p>This function returns either 0 (Success) or -1 (Failure)</p>

<h3><code>destroy_isocket()</code></h3>

<pre><code>int destroy_isocket(int sfd)
</code></pre>

<p><code>destroy_isocket()</code> <code>close()</code>s the specified Socket file descriptor <code>sfd</code>. It does not perform a <code>shutdown()</code> on it because that would produce
an error if you shut it down before. But that's equal because <code>close()</code> also sends EOF.</p>

<p>This function returns either 0 (Success) or -1 (Failure)</p>

<h2>Server</h2>

<p>libsocket also supports INET server sockets (also called Passive Sockets).</p>

<h3><code>create_issocket()</code></h3>

<p>'issocket' stands for 'Internet Server Socket', not for 'is socket'. :)</p>

<pre><code>int create_issocket(const char* bind_addr, const char* bind_port, char proto_osi4, char proto_osi3);
</code></pre>

<p>Creates a new server socket:</p>

<ul>
<li><code>bind_addr</code> is the address to bind to. It's normally good when you specify "0.0.0.0".</li>
<li><code>bind_port</code> is the port to bind to.</li>
<li>proto_osi4 is either TCP or UDP. If it's UDP, the socket doesn't <code>listen()</code>.</li>
<li>proto_osi3 is either IPv4 or IPv6</li>
</ul>

<p>The call to <code>listen()</code> (which is not executed when using UDP sockets uses the biggest linux backlog size 128. You should change it in the source code if you
want another value.</p>

<p>This function returns an int value suitable for calls with <code>accept()</code> and <code>socket_isaccept()</code>.</p>

<h3><code>socket_isaccept()</code></h3>

<pre><code>int socket_isaccept(int sfd, char* src_host, size_t src_host_len, char* src_service, size_t src_service_len, int flags);
</code></pre>

<p><code>socket_isaccept()</code> performs an action similar to <code>accept()</code>. <strong>It may not be called on UDP server sockets.</strong> </p>

<ul>
<li><code>sfd</code> is the socket file descriptor</li>
<li><code>src_host</code> is a pointer to a buffer into which the lib writes the hostname of the client. <code>src_host_len</code> is the length of its buffer. More bytes are truncated</li>
<li><code>src_service</code> and <code>src_service_len</code> is the same like <code>src_host</code> and <code>src_host_len</code>, but for the ports</li>
<li><code>flags</code> may be <code>NUMERIC</code>, which results in numeric host and service names.</li>
</ul>

<p><code>socket_isaccept()</code> returns a file descriptor for a connection to the client which is to be used with <code>read()</code> and <code>write()</code>. 
In case of failure, it returns -1. <code>socket_isaccept()</code> blocks until a client connects.</p>

<h1>Documentation for libunixsocket</h1>

<h2>Client</h2>

<h3><code>create_socket()</code></h3>

<pre><code>int create_usocket(const char* path, int socktype);
</code></pre>

<p>Creates and connects a new UNIX domain socket file descriptor for a socket located at <code>path</code>, type <code>socktype</code>.
<code>socktype</code> is either <code>STREAM</code> or <code>DGRAM</code>. </p>

<p>Important for DGRAM sockets: Please think twice if you want to use DGRAM sockets in UNIX domain. They do not have any advantages
over STREAM sockets!</p>

<h3><code>shutdown_socket()</code></h3>

<pre><code>int shutdown_socket(int sfd, int method)
</code></pre>

<p><code>shutdown_socket()</code> shuts a socket down. This means that (READ) you cannot read data anymore respectively (WRITE) you cannot write data anymore
and the other peer gets an EOF signal (<code>read()</code> returns 0).</p>

<ul>
<li><code>sfd</code> is the Socket File Descriptor</li>
<li><code>method</code> is either READ, WRITE or READ|WRITE (ORed).</li>
</ul>

<h3><code>destroy_socket()</code></h3>

<pre><code>int destroy_socket(int sfd)
</code></pre>

<p><code>destroy_socket()</code> shuts the socket down for READ and WRITE operations and <code>close()</code>s it.</p>

<h1>Compile options</h1>

<p>If you specify the flag <code>-DVERBOSE</code> at compile time, libsocket uses STDERR to print information about occurred errors.
VERBOSE is not activated by default so libsocket is 'quiet'.</p>
